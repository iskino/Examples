/*
Можно сделать конструктор явным, используя ключевое слово explicit (которое пишется перед именем конструктора).
Явные конструкторы (с ключевым словом explicit) не используются для неявных конвертаций:
Программа выше не скомпилируется, так как SomeString(int) мы сделали явным, а другого конструктора преобразования,
который бы выполнил неявную конвертацию ‘a’ в SomeString компилятор просто не нашел.

Однако использование явного конструктора только предотвращает выполнение неявных преобразований.
Явные конвертации (через операторы cast) по-прежнему разрешены:
std::cout << static_cast<SomeString>(7); // Разрешено: Явное преобразование 7 в SomeString через оператор cast

Еще при прямой или uniform инициализации неявная конвертация также будет выполняться:
SomeString str('a'); // Разрешено

Правило: Для предотвращения возникновения ошибок с неявными конвертациями – делайте ваши конструкторы явными,
используя ключевое слово explicit.
*/
#include <string>
#include <iostream>

class SomeString
{
private:
	std::string m_string;
public:
        // ключевое слово explicit делает этот конструктор закрытым для выполнения любых неявных преобразований
	explicit SomeString(int a) // выделяем строку размером a
	{
		m_string.resize(a);
	}

	SomeString(const char *string) // выделяем строку для хранения значения типа string
	{
		m_string = string;
	}

	friend std::ostream& operator<<(std::ostream& out, const SomeString &s);

};

std::ostream& operator<<(std::ostream& out, const SomeString &s)
{
	out << s.m_string;
	return out;
}

int main()
{
	SomeString mystring = 'a'; // ошибка компиляции, поскольку SomeString(int) теперь является explicit и, соответственно, недоступен, а другого подходящего конструктора для преобразования компилятор не видит
	std::cout << mystring;
	return 0;
}
