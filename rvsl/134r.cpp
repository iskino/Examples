/*
Обратите внимание, использование оператора + не изменяется (в обоих случаях, dollars1 + 3),
но реализация отличается. Наша дружественная функция с двумя параметрами становится
методом класса с одним параметром, причем левый параметр в перегрузке через
дружественную функцию (&dollars) в перегрузке через метод класса становится неявным объектом,
на который указывает указатель *this.

Рассмотрим детальнее, как обрабатывается выражение dollars1 + 3.

В перегрузке через дружественную функцию выражение dollars1 + 3 приводит к вызову функции
operator+(dollars1, 3). Здесь два параметра.

В перегрузке через метод класса выражение dollars1 + 3 приводит к вызову dollars1.operator+(3).
Обратите внимание, здесь уже один явный параметр, а dollars1 используется как префикс к operator+.
Этот префикс компилятор неявно конвертирует в скрытый левый параметр, на который указывает указатель *this.
Таким образом, dollars1.operator+(3) становится вызовом operator+(&dollars1, 3), что почти идентично
перегрузке через дружественную функцию.
*/
#include <iostream>

class Dollars
{
private:
    int m_dollars;

public:
    Dollars(int dollars) { m_dollars = dollars; }

    // Выполняем Dollars + int
    Dollars operator+(int value);

    int getDollars() { return m_dollars; }
};

// Примечание: Эта функция является методом класса!
// Вместо параметра dollars в перегрузке через дружественную функцию здесь неявный параметр, на который указывает указатель *this
Dollars Dollars::operator+(int value)
{
    return Dollars(m_dollars + value);
}

int main()
{
	Dollars dollars1(7);
	Dollars dollars2 = dollars1 + 3;
	std::cout << "I have " << dollars2.getDollars() << " dollars.\n";

	return 0;
}
