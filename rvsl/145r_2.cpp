/*Одним из решений этой проблемы является выполнение глубокого копирования.
При глубоком копировании память сначала выделяется для копирования адреса, который содержит исходный указатель,
а затем для копирования фактического значения. Таким образом копия находится в отдельной, от исходного значения,
памяти и они никак не влияют друг на друга. Для выполнения глубокого копирования нам необходимо написать
свой собственный конструктор копирования и перегрузку оператора присваивания.

Рассмотрим это на примере с классом SomeString:
*/

// Конструктор копирования
SomeString::SomeString(const SomeString& source)
{
    // поскольку m_length не является указателем, то мы можем выполнить поверхностное копирование
    m_length = source.m_length;

    // m_data является указателем, поэтому нам нужно выполнить глубокое копирование, при условии, что этот указатель не является нулевым
    if (source.m_data)
    {
        // выделяем память для нашей копии
        m_data = new char[m_length];

        // выполняем копирование
        for (int i=0; i < m_length; ++i)
            m_data[i] = source.m_data[i];
    }
    else
        m_data = 0;
}

/*
Как вы видите, реализация здесь более углублённая, нежели при поверхностном копировании!
Во-первых, мы должны проверить, имеет ли исходный объект ненулевое значение вообще (строка 8).
Если имеет, то мы выделяем достаточно памяти для хранения копии этого значения (строка 11).
Наконец, копируем значение-строку (строки 14 и 15).

Теперь рассмотрим перегрузку оператора присваивания:
*/

// Оператор присваивания
SomeString& SomeString::operator=(const SomeString & source)
{
    // проверка на самоприсваивание
    if (this == &source)
        return *this;

    // сначала нам нужно очистить предыдущее значение m_data (члена неявного объекта)
    delete[] m_data;

    // поскольку m_length не является указателем, то мы можем выполнить поверхностное копирование
    m_length = source.m_length;

    // m_data является указателем, поэтому нам нужно выполнить глубокое копирование, при условии, что этот указатель не является нулевым
    if (source.m_data)
    {
        // выделяем память для нашей копии
        m_data = new char[m_length];

        // выполняем копирование
        for (int i=0; i < m_length; ++i)
            m_data[i] = source.m_data[i];
    }
    else
        m_data = 0;

    return *this;
}
/*
При вызове перегруженного оператора присваивания, объект, которому присваивается другой объект,
может содержать предыдущее значение, которое нам необходимо очистить/удалить, прежде чем мы выделим память
для нового значения. С не динамически выделенными переменными (которые имеют фиксированный размер)
нам не нужно беспокоиться, поскольку новое значение просто перезапишет старое.
Однако с динамически выделенными переменными нам нужно явно освободить любую старую память до того,
как мы выделим любую новую память. Если мы этого не сделаем, сбоя не произойдет, но произойдет утечка памяти,
которая будет съедать нашу свободную память каждый раз, когда мы будем выполнять операцию присваивания!
*/
